const bindMap={},updBind=(e,a,d)=>{d&&e.set(a,d),bindMap[e.id].forEach(n=>n.update[a]?.(d??e.get(a)))},bind=(e,a,d,n,u)=>{const t=a.id;return bindMap[t]||(bindMap[t]=[]),bindMap[t].push(e),e.update||(e.update={}),e.update[d]=a=>e.value=a??'',e.onchange=()=>{let u=n?n(e.value):e.value;Number.isNaN(u)||null==u||(a.set(d,u),a.save(null,{useMasterKey:!0}).then(e=>{t&&updBind(e,d),msg('保存成功')},e=>{console.error(e),msg('保存失败',1)}))},e.update[d](a.get(d)??u),e},bindArr=(e,a,d,n,u,t)=>(e.onchange=()=>{let n=d?d(e.value):e.value;u&&u(n),e.send&&(t&&!t()||e.send()),e.parentNode.value[a]=n},setTimeout(e=>{let t=e.parentNode.value[a]??n;void 0!==t&&(e.value=t,u&&u(d?d(e.value):e.value))},10,e,u),e),bindUpd=(e,a,d,n)=>{const u=a.id;return bindMap[u]||(bindMap[u]=[]),bindMap[u].push(e),e.update||(e.update={}),e.update[d]=a=>n(e,a),e.update[d](a.get(d)),e};